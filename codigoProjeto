/* inicio do código do projeto de AED*/

#include <iostream>
#include <string>
#include <algorithm>  // Para usar swap
#include <random>     // Para random_device, mt19937 e uniform_int_distribution

using namespace std;

struct No{
    //dados contidos no nó
    int numCarta;
    string corCarta;
    No* ptrProximo; //ponteiro que aponta para o proximo nó
};

class Baralho{
private:
    No* ptrTopo;
    string cartaTopo[2];
    string matrizCartas[2][44];

public:
    Baralho(){
        ptrTopo = nullptr;
    }

    /*
    métodos
    */

    //método que verifica se a fila esta vazia
    bool estaVazia(){
        if (ptrTopo == nullptr){
            return true;
        }        else{
            return false;
        }
    }

    //método que adiciona um elemento ao ptrTopo da fila
    void adicionaElemento(int snumCarta, string scorCarta){
        No* novo = new No();
        novo->numCarta = snumCarta;
        novo->corCarta = scorCarta;
        novo->ptrProximo = ptrTopo;
        ptrTopo = novo;
    }

    //método para remover um item do ptrTopo da fila
    void removeElemento(){
        if (!estaVazia()){
            int numX = ptrTopo->numCarta;
            string corX = ptrTopo->corCarta;

            No* aux = ptrTopo;
            ptrTopo = ptrTopo->ptrProximo;
            delete aux;
            cout << "Carta " << numX << corX << " deletado com sucesso." << endl;
        } else{
            cout << "No esta vazio." << endl;
        }

    }

    //método para mostrar cor do topo
    int numTopo(){
        if (!estaVazia()){
            return ptrTopo->numCarta;
        }else{
            cout << " A pilha vazia ";
            return -1;
        }
    }

    //método para mostrar cor do topo
    string corTopo(){
        if (!estaVazia()){
            return ptrTopo->corCarta;
        }else{
            cout << " A pilha vazia ";
            return "-1";
        }
    }

 
    //método para mostrar elemento do topo
    void elementoTopo(){
        cartaTopo[0] = numTopo();
        cartaTopo[1] = corTopo();

        cout << "Carta do topo: " << cartaTopo[0] << cartaTopo[1] << endl;
    }

    void criarBaralho(){
        string corLocal[4] = {"verde", "vermelho", "azul", "amarelo"};
        int index = 0; 
        for(int l = 0; l<4; l++){
            for(int i = 0; i<11; i++){
                adicionaElemento(i, corLocal[l]);
                matrizCartas[0][index] = matrizCartas[0][index] = to_string(i);  // números como string para simplicidade
                matrizCartas[1][index] = corLocal[l];
                index++;
            }
        }
        
    }

    //método para varrer a pilha
    void varrerPilha(){
        No* aux = ptrTopo;

        if(aux == nullptr){
            cout << "Pilha vazia." << endl;
            return;
        } 

        while (aux!=nullptr){
            cout << aux->numCarta << " " << aux->corCarta << "\n -> \n" ;
            aux = aux->ptrProximo;
        }

        cout << "null" << endl;
    }

    void embaralha(){
        // Embaralhar as colunas
        random_device rd;
        mt19937 g(rd());

        for(int i = 43; i > 0; i--){ // algoritmo Fisher-Yates
            uniform_int_distribution<int> dist(0, i);
            int j = dist(g);

            // Trocar coluna i com coluna j
            swap(matrizCartas[0][i], matrizCartas[0][j]);
            swap(matrizCartas[1][i], matrizCartas[1][j]);
        }
    }

    //método para imprimir a matriz embaralhada:
    void imprimeMatriz(){
        for(int i=0;i<44;i++){
            cout << matrizCartas[0][i] << " - " << matrizCartas[1][i] << endl;
        }
    }


};

int main(){
    Baralho monte;
    monte.criarBaralho();
    monte.varrerPilha();

    monte.embaralha();
    monte.imprimeMatriz();
}